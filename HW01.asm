; востанавливаю код примера
; 
section .data
	textBuf db 'Hello, World'
	global _start;
	
section .text; 
  start:
	mov rax, 1 	; 1- согласно таблице системного вызова - команда "write" с сигнататурой (unsigned int fd, const char *buf, size_t count)
	
   ;аргумент для fd
	mov rdi, 1	; Это первый аргумент для команды "write". Если верно понял, то мы обращаемся к stdout, файл которого имеет номер 1 поэтому для df из сигнатуры write записываем 1
   ; аргумент для *buf
	mov rsi, textBuf ; буфер со строкой обьявлен ранее. В регистр rsi передаем адрес первого элемента буфера
   ; аргумент для count
   ; тут два варианта можно просто записать число (mov rdx, 12), в источниках наел вариант с "$-" но проверить возможности нет поэтому оставлю вариант 1
	mov rdx, 12	; количество выводимых символов = количество символов в Hello, World
	syscall		; запускаем системны вызов

   
   ; пример на этом закончен, но для правильной работы по завершению нужно вернуть значение "0", что бы ОС поняла что программа выполнена правильно. иначе надо вернуть код ошибки.
   ; поэтому сначала пишим в rax код команды "exit" и согласно сигнатуре "exit" - int error_code в регистр rdi записываем код ошибки.
	mov rax, 60	; вызов команды "exit"
	mov rdi, 0	; успешное завершение программы
	syscall		; запускаем системны вызов