
; Сначала создаем файл, затем, открываем, записываем данные, закрываем, выходим (возвращаем 0)

section .data	; переменные

	textBuf db 'Hello, World'	;  текст которой запишем в файл 
	nameBuf db 'print_HelloWorld'	;  имя создаваемого файла 
	global _start;
	
section. text	; 
	_start	;

	sub fileDiscr, 40 

; создание файла с помощью "__64_sys_creat"
	mov rax, 85 	; 85- согласно таблице системного вызова - команда "sys_creat" с сигнататурой (const char *pathname, umode_t mode)
	; поределяем *pathname (адрес начала строки имени файла)
	mov rbx, nameBuf ; в базовый регистр адреса записываем адрес пременной имени создаваемого файла. (это превый аргумент для "sys_creat" )
	; mode -права для файла
	mov rdi, ???? 	; тут надо записать права для файла пока не знаю что т.к. ссылка fs/open.c:1492 не работает()
	syscall		; запускаем системны вызов для "sys_creat" 

; чтение файла с помощью "__64_sys_open"
	mov rax, 2	; 2 - согласно таблице системного вызова - команда "sys_open" с сигнататуройconst char *filename, int flags, umode_t mode

	mov rbx, nameBuf ; в базовый регистр адреса записываем адрес первого элемента имини файла для открытия (*filename)
	mov rcx, ???? ; в регистр пшием значение для flags 
	mov rdx, ???? ; в регистр пшием значение для mode (какие права для файла) надо записать значение для полных прав.
	syscall		; запускаем системны вызов для "sys_open" 

	mov [fileDiscr], eax ; сохраняем файловый дескриптор из регистра eax 

; надо как-то проверить открытие файла 

; запись данных в файл "__64_sys_writev"
	mov rax, 20 	; я думаю надо использовать "sys_writev" для записи данных в файл. сигнатура для "sys_writev " - (unsigned long fd, const struct iovec *vec, unsigned long vlen)
	; значение для fd я думаю надо писать в регистр rbx (регистр базы стека).
	mov rbx, [fileDiscr]	; в регистр базы стека помещяем файловый дескриптор 
	; значение *vec - думаю это то, что пишем, думаю надо в  регистр источника для операций с массивом
	mov rsi, textBuf  	; пишем адрес того что записываем 
	; значение для vlen - думаю это длина записываемого буфера
	mov rcx, 12		; в регистр счетчика записываем количество символов в переменной rsi,textBuf  
	syscall		; запускаем системны вызов для "sys_writev" 



; закрываем файл с помощью "__64_sys_close"
	
	mov rax, 3;	3 - согласно таблице системного вызова - команда "sys_close" с сигнататуройconst unsigned int fd
	; значение для fd я думаю надо писать в регистр rbx (регистр базы стека).
	mov rbx, [fileDiscr]	; в регистр базы стека помещяем файловый дескриптор 
	syscall		; запускаем системны вызов "sys_close" 

; завершаем программу
	mov rax, 60	; вызов команды "exit"
	mov rdi, 0	; успешное завершение программы
	syscall		; запускаем системны вызов